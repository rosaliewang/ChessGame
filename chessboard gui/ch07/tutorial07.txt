<img src="http://proghammer.files.wordpress.com/2010/09/chessgame_72.jpg" alt="chess icon 72" title="chessgame_72" width="72" height="72" class="alignleft size-full wp-image-102" /> In this article we will have a deeper look at the game flow logic and do some preparations for the next article, which will introduce a computer controlled player using artificial intelligence.
<!--more-->
<blockquote>
This is the seventh part in a series of articles about programming a chess game in Java using Swing. As all articles build upon each other, I encourage you to also have a look at the previous articles in this series (<a href="http://proghammer.wordpress.com/2010/08/10/chess01-dragging-game-pieces/">Chess01: Dragging game pieces</a>, <a href="http://proghammer.wordpress.com/2010/08/16/chess02-introducing-game-state/">Chess02: Introducing game state</a>, <a href="http://proghammer.wordpress.com/2010/09/10/chess03-separating-game-logic-from-user-interface-logic/">Chess03: Separating view and logic</a>, <a href="http://proghammer.wordpress.com/2010/09/16/chess04-implementing-an-alternative-user-interface/">Chess04: Implementing an alternative user interface</a>, <a href="http://proghammer.wordpress.com/2010/09/22/chess05-enforcing-game-rules/">Chess05: Enforcing game rules</a>).
</blockquote>

When we think about programming a board game we usually can come up with a simple game flow concept quite easily. In chess I would intuitively start with something like:

[sourcecode language="java"]
while( !gameEndConditionReached() ){
       move = currentPlayer.getMove();
       executeMove(move);
       switchCurrentPlayer();
}
[/sourcecode]

Looking back at the code I presented in the previous articles, there is nothing like this. In fact the game flow is driven by the user interface. It is the user interface who calls the method movePiece() of the ChessGame class and not the ChessGame class asking the user interface for a valid move. It works, but I would argue that it would be more intuitive to have something like a game flow loop as shown above. So let's give the control of the game flow to the ChessGame class. We will see later, that this has in fact some interesting advantages.

First of all we make the ChessGame implement the Runnable interface, so that it can be run as a thread.

[sourcecode language="java"]

public class ChessGame implements Runnable{
       //..
}

[/sourcecode]

Then we add a method to register clients as players. Therefore we introduce a new interface called IPlayerHandler, which encapsulates all methods that the client needs to provide to be a valid player.

[sourcecode language="java"]
public class ChessGame implements Runnable{
       //..
	private IPlayerHandler blackPlayerHandler;
	private IPlayerHandler whitePlayerHandler;
	private IPlayerHandler activePlayerHandler;
	
	/**
	 * set the player/client for the specified piece color
	 * @param pieceColor - the color the client/player controls
	 * @param playerHandler - the player/client
	 */
	public void setPlayer(int pieceColor, IPlayerHandler playerHandler){
		switch (pieceColor) {
			case Piece.COLOR_BLACK: this.blackPlayerHandler = playerHandler; break;
			case Piece.COLOR_WHITE: this.whitePlayerHandler = playerHandler; break;
			default: throw new IllegalArgumentException("Invalid pieceColor: "+pieceColor);
		}
	}
	//..
}
[/sourcecode]

[sourcecode language="java"]
public interface IPlayerHandler {
	//..
}
[/sourcecode]

Afterwards we implement the main game flow logic.

[sourcecode language="java"]
public class ChessGame implements Runnable{

       //..

	@Override
	public void run() {
		this.startGame();
	}

	/**
	 * start main game flow
	 */
	public void startGame(){
		// check if all players are ready
		System.out.println("ChessGame: waiting for players");
		while (this.blackPlayerHandler == null || this.whitePlayerHandler == null){
			// players are still missing
			try {Thread.sleep(1000);} catch (InterruptedException e) {}
		}

		// set start player
		this.activePlayerHandler = this.whitePlayerHandler;

		// start game flow
		System.out.println("ChessGame: starting game flow");
		while(!isGameEndConditionReached()){
			waitForMove();
			swapActivePlayer();
		}

		System.out.println("ChessGame: game ended");
	}

	/**
	 * wait for a valid player move and execute it
	 */
	private void waitForMove() {
		Move move = null;
		// wait for a valid move
		do{
			move = this.activePlayerHandler.getMove();
			try {Thread.sleep(100);} catch (InterruptedException e) {}
		}while(move == null || !this.moveValidator.isMoveValid(move,false));

		//execute move
		boolean success = this.movePiece(move);
		if(success){
			this.blackPlayerHandler.moveSuccessfullyExecuted(move);
			this.whitePlayerHandler.moveSuccessfullyExecuted(move);
		}else{
			throw new IllegalStateException("move was valid, but failed to execute it");
		}
	}

	/**
	 * swap active player and update game state
	 */
	private void swapActivePlayer() {
		if( this.activePlayerHandler == this.whitePlayerHandler ){
			this.activePlayerHandler = this.blackPlayerHandler;
		}else{
			this.activePlayerHandler = this.whitePlayerHandler;
		}

		this.changeGameState();
	}

	//..
}
[/sourcecode]

While implementing the game flow logic, we can already see which methods the client classes will have to provide. The required methods are:

[sourcecode language="java"]
public interface IPlayerHandler {

	public Move getMove();

	public void moveSuccessfullyExecuted(Move move);

}
[/sourcecode]

Now we have achieved what we wanted. The ChessGame class is in control of the game flow logic. It will ask the current client/player to provide a valid move and afterwards it will execute it. In the end it will notify all clients about the successful execution of the move. This is mainly done so that the clients can update their user interface.

We still have to adjust our clients to this new game flow approach. First we will adapt the ChessConsole class.

[sourcecode language="java"]
public class ChessConsole implements IPlayerHandler{

       //..

	@Override
	public Move getMove() {
		System.out.println("your move (format: e2-e3): ");

		Move move = null;
		while(move == null){
			//read user input
			BufferedReader inputReader = new BufferedReader(new InputStreamReader(System.in));
			String input;
			try {
				input = inputReader.readLine();
			} catch (IOException e) {
				e.printStackTrace();
				continue;
			}
			// exit, if user types 'exit'
			if (input.equalsIgnoreCase("exit")){
				System.exit(0);
			}else{
				move = this.convertStringToMove(input);
			}
		}
		return move;
	}

	@Override
	public void moveSuccessfullyExecuted(Move move) {
		printCurrentGameState(this.chessGame);

		if( this.chessGame.getGameState() == ChessGame.GAME_STATE_END_BLACK_WON ){
			System.out.println("game end reached! Black won!");
		}else if( this.chessGame.getGameState() == ChessGame.GAME_STATE_END_WHITE_WON){
			System.out.println("game end reached! White won!");
		}
	}

       //..

}
[/sourcecode]

Now let's have a look at the ChessGui class. Here it is a bit trickier, as we want the user to be able to interact with the user interface even when it is not his turn. So the user interface is running in it's own thread. The approach I have taken is, that the user interface provides a null value back to the ChessGame class until the user has made a valid move.

[sourcecode language="java"]
public class ChessGui extends JPanel implements IPlayerHandler{

       //..

	@Override
	public Move getMove() {
		//..

		Move moveForExecution = this.currentMove;
		this.currentMove = null;
		return moveForExecution;
	}

	//..
}
[/sourcecode]

The move made by the user is stored in the currentMove variable of the ChessGui class. The variable is set in the old setNewPieceLocation() method.

[sourcecode language="java"]
public class ChessGui extends JPanel implements IPlayerHandler{

       //..

	/**
	 * set current move for the getMove() method if the location is valid.
	 * If the location is not valid, move the piece back to its original
	 * position.
	 * @param dragPiece
	 * @param x
	 * @param y
	 */
	public void setNewPieceLocation(GuiPiece dragPiece, int x, int y) {
		int targetRow = ChessGui.convertYToRow(y);
		int targetColumn = ChessGui.convertXToColumn(x);

		Move move = new Move(dragPiece.getPiece().getRow(), dragPiece.getPiece().getColumn()
				, targetRow, targetColumn);
		if( this.chessGame.getMoveValidator().isMoveValid(move, true) ){
			this.currentMove = move;
		}else{
			dragPiece.resetToUnderlyingPiecePosition();
		}
	}

	//..

}
[/sourcecode]

The variable is reset in the getMove() method. The getMove() method will also enable the user to drag game pieces around (draggingGamePiecesEnabled=true).

[sourcecode language="java"]
public class ChessGui extends JPanel implements IPlayerHandler{

       //..

	@Override
	public Move getMove() {
		this.draggingGamePiecesEnabled = true;

		//..
	}

	@Override
	public void moveSuccessfullyExecuted(Move move) {

		//..

		// disable dragging until asked by ChessGame for the next move
		this.draggingGamePiecesEnabled = false;

		//..

	}

	//..
}
[/sourcecode]

The moveSuccessfullyExecuted() method updates the moved GuiPiece, store the executed move in the variable lastMove for highlighting and disable the drag and drop functionality (draggingGamePiecesEnabled=false).

[sourcecode language="java"]
public class ChessGui extends JPanel implements IPlayerHandler{

       //..

	@Override
	public void moveSuccessfullyExecuted(Move move) {
		// adjust GUI piece
		GuiPiece guiPiece = this.getGuiPieceAt(move.targetRow, move.targetColumn);
		if( guiPiece == null){
			throw new IllegalStateException("no guiPiece at "+move.targetRow+"/"+move.targetColumn);
		}
		guiPiece.resetToUnderlyingPiecePosition();

		// remember last move
		this.lastMove = move;

		// disable dragging until asked by ChessGame for the next move
		this.draggingGamePiecesEnabled = false;

		// repaint the new state
		this.repaint();
	}

	//..
}
[/sourcecode]

The draggingGamePiecesEnabled variable is read by the PiecesDragAndDropListener class to decide if the user is currently allowed to drag game pieces or not.

[sourcecode language="java"]
public class PiecesDragAndDropListener implements MouseListener, MouseMotionListener {

       //..

	@Override
	public void mousePressed(MouseEvent evt) {
		if( !this.chessGui.isDraggingGamePiecesEnabled()){
			return;
		}

		//..
	}
	
	//..
	
}
[/sourcecode]

There are a few more things that I have changed in the code, but they are not really relevant for this article so I will only mention them briefly. First I split up the end state GAME_STATE_END into GAME_STATE_END_BLACK_WON and GAME_STATE_END_WHITE_WON. I introduced a few helper methods in the Piece class to convert rows, column and colors into Strings. The printCurrentGameState of the ChessConsole class is now static as the method is very useful for debugging.

The changes mentioned above have an interesting side effect. It is now possible to have different clients per player. You could for example play the Swing user interface against the console user interface or two swing interfaces against each other or two different console interfaces against each other. We will use this advantage in our next article in which we will build a computer controlled player using artificial intelligence.

Below is the code for starting a new game. As you can see, you can provide any client as a player and the application works just fine.

[sourcecode language="java"]
public class Main {

	public static void main(String[] args) {
		// first we create the game
		ChessGame chessGame = new ChessGame();
		
		// then we create the clients/players
		ChessGui chessGui = new ChessGui(chessGame);
		ChessConsole chessConsole = new ChessConsole(chessGame);
		
		// then we attach the clients/players to the game
		chessGame.setPlayer(Piece.COLOR_WHITE, chessGui);
		chessGame.setPlayer(Piece.COLOR_BLACK, chessConsole);
		
		// in the end we start the game
		new Thread(chessGame).start();
	}
	
}
[/sourcecode]

There is one thing which I didn't really talk about: concurrency. Now that the ChessGame class is a thread that is executed independently you have to be careful with possible concurrency issues. I did not really address the issue in the code, as the focus of the article is somewhere else, but you should keep this in mind.

That's it and thanks for reading.

Resources:

The source code (eclipse project): coming soon
The chess icons come from: <a href="http://ixian.com/chess/jin-piece-sets/">http://ixian.com/chess/jin-piece-sets/</a>
